Below is a **best-practice Dockerfile template for bioinformatics** (Linux), plus a **quick-start command set** to build, run, administer, and update it. This is designed for reproducibility (pinned versions, non-root user, sane defaults), and it works well for tools like **STAR/samtools/bcftools**, plus Python/R environments.

---

## Best-practice Dockerfile template (bioinformatics)

```dockerfile
# syntax=docker/dockerfile:1.7
# A practical, reproducible bioinformatics base image:
# - pinned base OS
# - minimal, explicit apt installs
# - non-root runtime user
# - optional micromamba for reproducible envs
# - good defaults for containers in pipelines (Nextflow/Snakemake)

ARG UBUNTU_VERSION=22.04
FROM ubuntu:${UBUNTU_VERSION}

# ---- Build metadata (useful for provenance) ----
ARG BUILD_DATE
ARG VCS_REF
ARG VERSION="0.1.0"

LABEL org.opencontainers.image.title="bioinformatics-base" \
      org.opencontainers.image.description="Best-practice bioinformatics base container" \
      org.opencontainers.image.version="${VERSION}" \
      org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.revision="${VCS_REF}" \
      org.opencontainers.image.licenses="MIT"

# Avoid interactive prompts during apt operations
ENV DEBIAN_FRONTEND=noninteractive \
    TZ=Etc/UTC

# ---- Core OS packages (keep this tight) ----
# Use BuildKit cache mounts for faster rebuilds.
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    apt-get update && \
    apt-get install -y --no-install-recommends \
      ca-certificates \
      curl \
      wget \
      git \
      bash \
      coreutils \
      bzip2 \
      unzip \
      xz-utils \
      gnupg \
      locales \
      tzdata \
      tini \
      procps \
      less \
      vim-tiny \
      openssh-client \
      # Common bioinfo build/runtime deps
      build-essential \
      pkg-config \
      zlib1g-dev \
      libbz2-dev \
      liblzma-dev \
      libcurl4-openssl-dev \
      libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# ---- Locale (helps R + some tools) ----
RUN locale-gen en_GB.UTF-8
ENV LANG=en_GB.UTF-8 \
    LC_ALL=en_GB.UTF-8

# ---- Create a non-root user for runtime safety ----
# Use a fixed UID/GID to behave nicely on shared filesystems.
ARG USERNAME=bio
ARG USER_UID=1000
ARG USER_GID=1000

RUN groupadd --gid ${USER_GID} ${USERNAME} && \
    useradd  --uid ${USER_UID} --gid ${USER_GID} -m -s /bin/bash ${USERNAME}

# ---- Recommended directory layout ----
# /opt/tools  : installed tools
# /opt/work   : default working directory (bind-mount here)
# /data       : optional data mount point
RUN mkdir -p /opt/tools /opt/work /data && \
    chown -R ${USERNAME}:${USERNAME} /opt/tools /opt/work /data

# ---- Optional: micromamba for reproducible environments ----
# Pin micromamba and use conda-lock later if you want fully locked envs.
ARG MICROMAMBA_VERSION=1.5.10
RUN curl -Ls https://micro.mamba.pm/api/micromamba/linux-64/${MICROMAMBA_VERSION} \
  | tar -xvj -C /usr/local/bin --strip-components=1 bin/micromamba

# Configure micromamba root + path
ENV MAMBA_ROOT_PREFIX=/opt/micromamba
ENV PATH=/opt/micromamba/bin:/opt/tools/bin:$PATH

# Example: create a baseline env (edit to suit)
# - Keep channels explicit
# - Pin major versions at least
# You can replace this entire block with your own env.yml.
COPY --chown=${USERNAME}:${USERNAME} env.yml /tmp/env.yml
RUN micromamba create -y -n bio -f /tmp/env.yml && \
    micromamba clean -a -y && \
    rm -f /tmp/env.yml

# Activate env by default for all shells and RUN commands
ENV MAMBA_DOCKERFILE_ACTIVATE=1
SHELL ["/bin/bash", "-lc"]

# ---- Add your pipeline code (copy late for better layer caching) ----
# Put small wrapper scripts in /usr/local/bin
COPY --chown=${USERNAME}:${USERNAME} bin/ /usr/local/bin/
RUN chmod +x /usr/local/bin/* || true

# Set working dir and switch to non-root
WORKDIR /opt/work
USER ${USERNAME}

# Use tini as PID1 to forward signals cleanly (important for pipelines)
ENTRYPOINT ["/usr/bin/tini", "--"]

# Default: open a shell. Pipelines override CMD/ENTRYPOINT as needed.
CMD ["bash"]
```

### Example `env.yml` (edit to your needs)

```yaml
name: bio
channels:
  - conda-forge
  - bioconda
dependencies:
  - python=3.11
  - pip
  - samtools=1.20
  - bcftools=1.20
  - bedtools=2.31
  - fastqc=0.12.1
  - multiqc=1.21
  - star=2.7.11b
  - pigz=2.8
  - parallel=20240122
  - pip:
      - pandas==2.2.2
      - numpy==2.0.1
```

> Tip: for serious reproducibility, generate a lock file (e.g., `conda-lock`) and build from that.

---

## Quick-start commands (implement + administer + update)

### 0) Recommended repo layout

```text
.
├─ Dockerfile
├─ env.yml
├─ bin/
│  ├─ run_star.sh
│  └─ smoke_test.sh
└─ README.md
```

### 1) Build (local)

```bash
# Enable BuildKit for faster cached builds
export DOCKER_BUILDKIT=1

# Build with metadata labels
docker build \
  --build-arg BUILD_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  --build-arg VCS_REF="$(git rev-parse --short HEAD 2>/dev/null || echo 'na')" \
  --build-arg VERSION="0.1.0" \
  -t bio-base:0.1.0 .
```

### 2) Run interactively with a working directory mounted

```bash
mkdir -p work data

docker run --rm -it \
  -v "$PWD/work:/opt/work" \
  -v "$PWD/data:/data:ro" \
  bio-base:0.1.0
```

### 3) Confirm tools / sanity check

```bash
docker run --rm bio-base:0.1.0 bash -lc "python --version && samtools --version | head -n 1 && STAR --version"
```

### 4) Administration basics

List images/containers:

```bash
docker images | head
docker ps
docker ps -a
```

Inspect image labels / provenance:

```bash
docker inspect bio-base:0.1.0 --format '{{json .Config.Labels}}' | jq
```

See what’s taking space:

```bash
docker system df
```

Cleanup dangling build cache (careful):

```bash
docker builder prune
# or more aggressive:
docker system prune
```

### 5) Update workflow (safe + reproducible)

**Option A: update tool versions in `env.yml`** (recommended), then rebuild:

```bash
# edit env.yml (bump STAR/samtools/etc)
docker build -t bio-base:0.2.0 .
```

**Option B: rebuild from scratch to ensure no stale caches:**

```bash
docker build --no-cache -t bio-base:0.2.0 .
```

### 6) Smoke test pattern (best practice)

Create `bin/smoke_test.sh` that runs quickly and checks key tools:

```bash
docker run --rm bio-base:0.2.0 bash -lc "/usr/local/bin/smoke_test.sh"
```

### 7) Tagging strategy

```bash
docker tag bio-base:0.2.0 bio-base:latest
```

(For scientific work: prefer **version tags** in pipelines; treat `latest` as convenience only.)

### 8) Push to a registry (Azure ACR example)

```bash
# 1) Login to ACR
az acr login --name <your-acr-name>

# 2) Tag for ACR
docker tag bio-base:0.2.0 <your-acr-name>.azurecr.io/bio-base:0.2.0

# 3) Push
docker push <your-acr-name>.azurecr.io/bio-base:0.2.0
```

Pull elsewhere:

```bash
docker pull <your-acr-name>.azurecr.io/bio-base:0.2.0
```

---

## Practical bioinformatics notes

* **Don’t bake large reference genomes** into the image. Mount them (`/data`) or fetch from object storage at runtime (Blob/S3/GCS).
* Use **non-root** for safer defaults; it also prevents “mystery root-owned outputs” on shared mounts.
* Prefer **pinned versions** (STAR/samtools/etc) and a lockfile if you need strict reproducibility.
* Use `tini` so signals propagate properly (important when orchestrators stop jobs, and for Nextflow/Snakemake process handling).

